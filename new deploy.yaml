# .github/workflows/reusable-deploy.yml
name: Reusable Deploy Workflow

on:
  workflow_call:
    inputs:
      environment:
        description: "Deployment environment (e.g., staging, production)"
        required: true
        type: string
      namespace:
        description: "Kubernetes namespace for deployment"
        required: true
        type: string
      image_tag:
        description: "Docker image tag to deploy"
        required: true
        type: string
      openshift_server:
        description: "OpenShift server URL"
        required: false
        type: string
    secrets:
      CONJUR_HOST_PRIV_ID:
        description: "Conjur Host Privileged ID"
        required: true
      CONJUR_HOST_PRIV_KEY:
        description: "Conjur Host Privileged Key"
        required: true
      OPENSIFT_SA_TOKEN:
        description: "OpenShift Service Account Token"
        required: true
      OPENSIFT_SERVER:
        description: "OpenShift API server URL (optional if provided via input)"
        required: false

jobs:
  deploy:
    # single job so callers don't need to depend on other jobs
    name: Deploy to OpenShift
    runs-on: ubuntu-latest
    timeout-minutes: 40
    steps:

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install oc (OpenShift CLI) and helm
        run: |
          set -euo pipefail
          # install oc
          curl -sS -L "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/oc.tar.gz" -o oc.tar.gz
          tar -xzf oc.tar.gz
          sudo mv oc /usr/local/bin/oc || sudo mv $(pwd)/oc /usr/local/bin/oc || true
          rm -f oc.tar.gz
          oc version || true

          # install helm
          curl -fsSL https://get.helm.sh/helm-v3.14.4-linux-amd64.tar.gz -o helm.tar.gz
          tar -xzf helm.tar.gz
          sudo mv linux-amd64/helm /usr/local/bin/helm
          rm -rf linux-amd64 helm.tar.gz
          helm version

      - name: Determine OpenShift server
        id: server
        run: |
          # prefer explicit input then fallback to secret
          if [ -n "${{ inputs.openshift_server }}" ]; then
            echo "server=${{ inputs.openshift_server }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ secrets.OPENSIFT_SERVER }}" ]; then
            echo "server=${{ secrets.OPENSIFT_SERVER }}" >> $GITHUB_OUTPUT
          else
            echo "server=" >> $GITHUB_OUTPUT
          fi

      - name: Login to OpenShift
        run: |
          set -euo pipefail
          if [ -z "${{ steps.server.outputs.server }}" ]; then
            echo "No OpenShift server provided (input or secret). Aborting."
            exit 1
          fi
          echo "Logging into OpenShift server ${ { steps.server.outputs.server } }"
          oc login --token="${{ secrets.OPENSIFT_SA_TOKEN }}" --server="${{ steps.server.outputs.server }}" --insecure-skip-tls-verify=false
        # keep token usage in run for auditability

      - name: Ensure namespace exists and switch
        run: |
          set -euo pipefail
          NS="${{ inputs.namespace }}"
          if oc get namespace "$NS" >/dev/null 2>&1; then
            echo "Namespace $NS exists - switching"
          else
            echo "Namespace $NS does not exist - creating"
            oc create namespace "$NS"
          fi
          oc project "$NS"

      - name: Helm lint + Dry Run
        run: |
          set -euo pipefail
          # Chart path - adjust if your chart path differs
          CHART_PATH="./apps/psirt/pgqd/images/app/helm"
          helm lint "$CHART_PATH" || true   # lint warnings shouldn't stop, but you can remove || true to fail on lint errors

      - name: Helm upgrade / install (deploy)
        run: |
          set -euo pipefail
          CHART_PATH="./apps/psirt/pgqd/images/app/helm"
          RELEASE_NAME="pgqd"
          NS="${{ inputs.namespace }}"
          IMAGE_TAG="${{ inputs.image_tag }}"

          # Use --wait so helm will wait for rollout; tune timeout as needed
          helm upgrade --install "$RELEASE_NAME" "$CHART_PATH" \
            --namespace "$NS" \
            --create-namespace \
            --set image.tag="$IMAGE_TAG" \
            --wait --timeout 10m

      - name: Helm status
        run: |
          set -euo pipefail
          helm status pgqd --namespace "${{ inputs.namespace }}" || true

      - name: Apply raw Kubernetes manifests (optional)
        if: ${{ always() }}
        run: |
          set -euo pipefail
          # If you also have a standalone deployment.yaml you want applied:
          if [ -f "./apps/psirt/pgqd/templates/deployment.yaml" ]; then
            oc apply -f ./apps/psirt/pgqd/templates/deployment.yaml -n "${{ inputs.namespace }}" || true
          else
            echo "No explicit deployment.yaml present at ./apps/psirt/pgqd/templates/deployment.yaml - skipping oc apply"
          fi

      - name: Verify deployment pods are running
        run: |
          set -euo pipefail
          NS="${{ inputs.namespace }}"
          echo "Checking pods status in $NS..."
          kubectl get deployments -n "$NS" || true
          echo "Waiting for pods to be running (timeout 5m)..."
          end=$((SECONDS+300))
          while [ $SECONDS -lt $end ]; do
            NOTREADY=$(kubectl get pods -n "$NS" --no-headers 2>/dev/null || true | awk '{print $3}' | grep -v -E '^(Running|Completed)$' || true)
            if [ -z "$NOTREADY" ]; then
              echo "All pods Running/Completed"
              kubectl get pods -n "$NS"
              exit 0
            fi
            echo "Pods not ready yet; statuses:"; kubectl get pods -n "$NS" --no-headers || true
            sleep 8
          done
          echo "Timeout waiting for pods to be ready. Showing pods:"
          kubectl get pods -n "$NS" --show-all || true
          exit 1
